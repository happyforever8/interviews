## 题目地址
https://leetcode.com/problems/word-search/

## 题目描述
```
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
```

## 思路

在2D表中搜索是否有满足给定单词的字符组合，要求所有字符都是相邻的（方向不限). 题中也没有要求字符的起始和结束位置。

在起始位置不确定的情况下，扫描二维数组，找到字符跟给定单词的第一个字符相同的，四个方向（上，下，左，右）分别DFS搜索，
如果任意方向满足条件，则返回结果。不满足，回溯，重新搜索。

举例说明：如图二维数组，单词："SEE"
```
1. 扫描二维数组，找到board[1,0] = word[0]，匹配单词首字母。
2. 做DFS（上，下，左，右 四个方向）

如下图：
```
![word search 1](../../../../resources/img/79.word-search-1.png)

起始位置（1，0），判断相邻的字符是否匹配单词下一个字符 `E`.
```
1. 标记当前字符（1，0）为已经访问过，board[1][0] = '*'
2. 上（0，0）字符为 'A' 不匹配, 
3. 下（2，0）字符为 'A'，不匹配,
4. 左（-1，0）超越边界，不匹配,
5. 右（1，1）字符 'F'，不匹配

如下图：
```
![word search 2](../../../../resources/img/79.word-search-2.png)

由于从起始位置DFS都不满足条件，所以
```
1. 回溯，标记起始位置（1，0）为未访问。board[1][0] = 'S'. 
2. 然后继续扫描二维数组，找到下一个起始位置（1，3）

如下图：
```
![word search 3](../../../../resources/img/79.word-search-3.png)

起始位置（1，3），判断相邻的字符是否匹配单词下一个字符 `E`.
```
1. 标记当前字符（1, 3）为已经访问过，board[1][3] = '*'
2. 上（0，3）字符为 'E', 匹配, 继续递归搜索
3. 下（2，3）字符为 'E'，匹配, 
   - 等待#2中（0，3）满足条件递归结果，
   - 如果满足，直接返回，
   - 如果#2递归不匹配所有单词，则继续（2，3）递归搜索
4. 左（1，2）字符为 'C'，不匹配,
5. 右（1，4）超越边界，不匹配

如下图：
```
![word search 4](../../../../resources/img/79.word-search-4.png)

位置（0，3）满足条件，继续DFS，判断相邻的字符是否匹配单词下一个字符 `E`
```
1. 标记当前字符（0，3）为已经访问过，board[0][3] = '*'
2. 上 （-1，3）超越边界，不匹配
3. 下（1，3）已经访问过，
4. 左（0，2）字符为 'C'，不匹配
5. 右（1，4）超越边界，不匹配

如下图
```
![word search 5](../../../../resources/img/79.word-search-5.png)

从位置（0，3）DFS不满足条件，
```
1. 回溯，标记起始位置（0，3）为未访问。board[0][3] = 'E'. 
2. 回到满足条件的位置（2，3），继续DFS搜索，判断相邻的字符是否匹配单词下一个字符 'E'
3. 上 (1，3）已访问过
4. 下（3，3）超越边界，不匹配
5. 左（2，2）字符为 'E'，匹配
6. 右（2，4）超越边界，不匹配

如下图：
```
![word search 6](../../../../resources/img/79.word-search-6.png)

单词匹配完成，满足条件，返回 `True`.
![word search 7](../../../../resources/img/79.word-search-7.png)

#### 复杂度分析
- *时间复杂度：* `O(m*n) - m 是二维数组行数， n 是二维数组列数`
- *空间复杂度：* `O(1) - 这里在原数组中标记当前访问过，没有用到额外空间`

>**注意**：如果用 Set 或者是 boolean[][]来标记字符位置是否已经访问过，需要额外的空间 `O(m*n)`.

## 关键点分析
- 遍历二维数组的每一个点，找到起始点相同的字符，做DFS
- DFS过程中，要记录已经访问过的节点，防止重复遍历，这里（Java Code中）用 `*` 表示当前已经访问过，也可以用Set或者是boolean[][]数组记录访问过的节点位置。
- 是否匹配当前单词中的字符，不符合回溯，这里记得把当前 `*` 重新设为当前字符。如果用Set或者是boolean[][]数组，记得把当前位置重设为没有访问过。

## 代码 (`Java/Javascript/Python3`)
*Java Code*
```java
public class LC79WordSearch {
  public boolean exist(char[][] board, String word) {
    if (board == null || board.length == 0 || board[0].length == 0
        || word == null || word.length() == 0) return true;
    int rows = board.length;
    int cols = board[0].length;
    for (int r = 0; r < rows; r++) {
      for (int c = 0; c < cols; c++) {
        if (board[r][c] == word.charAt(0)) {
          if (helper(board, word, r, c, 0)) {
            return true;
          }
        }
      }
    }
    return false;
  }
  
  private boolean helper(char[][] board, String word, int r, int c, int start) {
    if (start == word.length()) return true;
    if (!isValid(board, r, c) ||
        board[r][c] != word.charAt(start)) return false;
    board[r][c] = '*';
    boolean res = helper(board, word, r + 1, c, start + 1)
        ||  helper(board, word, r, c + 1, start + 1)
        ||  helper(board, word, r - 1, c, start + 1)
        ||  helper(board, word, r, c - 1, start + 1);
    board[r][c] = word.charAt(start);
    return res;
  }
  
  private boolean isValid(char[][] board, int r, int c) {
    return r >= 0 && r < board.length && c >= 0 && c < board[0].length;
  }
}
```

*Python3 Code*
```python


```

*Javascript Code* from [**@xiongcaihu**](https://github.com/xiongcaihu)
```javascript
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function (board, word) {
    var visited = Array.from({
        length: board.length
    }, () => new Array(board.length).fill(false));

    for (var i = 0; i < board.length; i++) {
        for (var j = 0; j < board[i].length; j++) {
            if (board[i][j] == word[0]) {
                if (temp(i, j, 0)) {
                    return true;
                }
            }
        }
    }
    return false;

    function temp(x, y, index) {
        if (x < 0 || y < 0 || x >= board.length || y >= board[0].length) return false;
        if (visited[x][y]) return false;
        if (index == word.length - 1 && board[x][y] == word[index]) return true;
        if (board[x][y] != word[index]) return false;

        visited[x][y] = true;
        var rel = temp(x - 1, y, index + 1) || temp(x + 1, y, index + 1) || temp(x, y - 1, index + 1) || temp(x, y + 1, index + 1);
        if (rel) return true;
        visited[x][y] = false;
        return false;
    }
};
```

## 参考（References）
1. [回溯法 Wiki](https://www.wikiwand.com/zh/%E5%9B%9E%E6%BA%AF%E6%B3%95)